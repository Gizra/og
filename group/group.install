<?php
// $Id$

/**
 * @file
 * Install, update, and uninstall functions for the Group module.
 */

/**
 * Implement hook_enable().
 *
 * Add group audience to users by default. This can't be in hook_install() as
 * the field isn't known yet.
 */
function group_enable() {
  group_create_field('group_audience', 'user', 'user');

  // Set default roles and permissions.
  group_set_global_access();
}


/**
 * Implement hook_uninstall().
 */
function group_uninstall() {
  $vars = array(
    'group_context',
    'group_group_manager_full_access',
    'group_skip_access',
  );
  foreach ($vars as $var) {
    variable_del($var);
  }
}


/**
 * Implement hook_schema().
 */
function group_schema() {
  $schema = array();

  $schema['group_groups'] = array(
    'description'     => 'Store information related to the groups.',
    'fields'          => array(
      'gid' => array(
        'description' => "The group's unique ID.",
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'etid' => array(
        'description' => "The entity ID.",
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'entity_type' => array(
        'description' => "The entity type (e.g. node, comment, etc').",
        'type' => 'varchar',
        'length' => '32',
        'not null' => TRUE,
        'default' => '',
      ),
      'label' => array(
        'description' => "The entity label (e.g. node's title).",
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => '',
      ),
      'state' => array(
        'description' => 'The state of the group (i.e. active or disabled).',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 1,
      ),
	    'created' => array(
	      'description' => 'The Unix timestamp when the group was created.',
	      'type' => 'int',
	      'not null' => TRUE,
	      'default' => 0,
	    ),
    ),
    'primary key' => array('gid'),
  );

  $schema['group_role_permission'] = array(
    'description' => 'Stores the permissions assigned to user roles per group.',
    'fields' => array(
      'rid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'description' => 'Foreign Key: {role}.rid.',
      ),
      'permission' => array(
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => '',
        'description' => 'A single permission granted to the role identified by rid.',
      ),
      'module' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
        'description' => "The module declaring the permission.",
      ),
    ),
    'primary key' => array('rid', 'permission'),
    'indexes' => array(
      'permission' => array('permission'),
    ),
    'foreign keys' => array(
      'rid' => array('role' => 'rid'),
    ),
  );

  $schema['group_role'] = array(
    'description' => 'Stores user roles per group.',
    'fields' => array(
      'rid' => array(
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'description' => 'Primary Key: Unique role ID.',
      ),
      'gid'               => array(
        'description'     => "The group's unique ID.",
        'type'            => 'int',
        'size'            => 'normal',
        'not null'        => TRUE,
      ),
      'name' => array(
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => '',
        'description' => 'Unique role name per group.',
      ),
    ),
    'primary key' => array('rid'),
  );

  $schema['group_users_roles'] = array(
    'description' => 'Maps users to roles.',
    'fields' => array(
      'uid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'Primary Key: {users}.uid for user.',
      ),
      'rid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
        'description' => 'Primary Key: {group_role}.rid for role.',
      ),
      'gid'               => array(
        'description'     => "The group's unique ID.",
        'type'            => 'int',
        'size'            => 'normal',
        'not null'        => TRUE,
      ),
    ),
    'primary key' => array('uid', 'rid', 'gid'),
    'indexes' => array(
      'rid' => array('rid'),
    ),
    'foreign keys' => array(
      'uid' => array('users' => 'uid'),
      'rid' => array('group_role' => 'rid'),
    ),
  );

  return $schema;
}

if (module_exists('group')) {
  /**
   * Upgrade from Organic groups to Group.
   *
   * Pattern taken from node_update_7006().
   *
   * Upgrade path from Organic groups for Drupal 6 to Group for Drupal 7:
   * - Add group fields to nodes.
   * - Move Organic groups' data into the fields of group.
   * - Delete Organic groups' variables.
   */
  function group_update_7000(&$context) {
    if (db_table_exists('og')) {
      $context['#finished'] = 0;

      $content_type = array('group' => array(), 'group content' => array());

      // If this is the first time this functions is called in the batch process,
      // create fields for the content types.
      if (!isset($context['total'])) {

        foreach (node_type_get_types() as $type) {
          // check if the variable exists.
          if ($type_usage = variable_get('og_content_type_usage_' . $type->type)) {
            switch ($type_usage) {
              case 'group':
                $content_type['group'][] = $type->type;
                break;

              case 'group_post_standard':
              case 'group_post_wiki':
                // The type of the group content is now determined via the
                // group permissions. We only care about adding the group content
                // fields to the node.
                $content_type['group content'][] = $type->type;
                break;

            }

            // TODO: Delete variable.
          }
        }

        if ($content_type) {
          // Add group and group content fields to content types.
          $fields = array(
            'group' => GROUP_GROUP_FIELD,
            'group content' => GROUP_AUDIENCE_FIELD,
          );
          foreach ($fields as $key => $field_name) {
            foreach ($content_type[$key] as $type) {
              group_create_field($field_name, 'node', $type);
            }
          }
        }

        // Initialize state for future calls.
        $context['last'] = 0;
        $context['count'] = 0;

        // Hold the information about the callbacks that upgrade the different
        // fields.
        $context['group upgrade'] = array('group', 'group_content', 'user');

        $query = db_select('og', 'og');
        $group_total = $query->countQuery()->execute()->fetchField();

        $query = db_select('og_ancestry', 'oga');
        $group_content_total = $query->countQuery()->execute()->fetchField();

        $query = db_select('og_uid', 'ogu');
        $group_user_total = $query->countQuery()->execute()->fetchField();

        $context += array(
          'group_total' => $group_total,
          'group_content_total' => $group_content_total,
          'group_user_total' => $group_user_total,
        );

          // Sum of all enteties to be converted.
        $context['total'] = $group_total + $group_content_total + $group_user_total;
      }
      else {
        if ($context['total']) {
          $callback = reset($context['group upgrade']);
          $callback =  '_group_upgrade_' . $callback;

          // We don't use call_user_func, as we want to pass $context by
          // reference.
          $found = $callback($context);

          if (!$found) {
            // Continue to the next upgrade element.
            $context['last'] = 0;
            array_shift($context['group upgrade']);
          }

          $context['#finished'] = min(0.99, $context['count'] / ($context['group'] + $context['group content']));
        }
      }
      if (empty($context['group upgrade'])) {
        // All nodes are processed.

        // We're done.
        $context['#finished'] = 1;
        return t("!number groups and group content converted to use new Group fields.", array('!number' => $context['total']));
      }
    }
  }
}

/**
 * Helper function; Upgrade "group" nodes.
 */
function _group_upgrade_group(&$context) {
  $found = FALSE;

  // Operate on every revision of every node, in batches.
  $batch_size = 200;
  $query = db_select('node_revision', 'nr');
  $query->innerJoin('node', 'n', 'n.vid = nr.vid');
  $query->innerJoin('og', 'og', 'n.nid = og.nid');
  $query
    ->fields('nr', array('nid', 'vid'))
    ->fields('n', array('type', 'created'))
    ->condition('nr.vid', $context['last'], '>')
    ->orderBy('nr.vid', 'ASC')
    ->range(0, $batch_size);
  $revisions = $query->execute();

  // Holds the node IDs with their earliest revision and timestamp, to create a
  // group entity with the earliest timestamp.
  $nids = array();
  foreach ($revisions as $revision) {
    $found = TRUE;

    $node = (object) array(
      'nid' => $revision->nid,
      'vid' => $revision->vid,
      'type' => $revision->type,
    );

    if (empty($nids[$revision->nid]) || $nids[$revision->nid] > $revision->created) {
      $nids[$revision->nid] = $revision->created;
    }

    // Set field values.
    $node->{GROUP_GROUP_FIELD}[LANGUAGE_NONE][0]['value'] = TRUE;

    field_attach_update('node', $node);

    $context['last'] = $revision->vid;
  }

  // Update group enteties with the correct "created" timestamp. The group
  // enteties were already created in the above field_attach_update(), but we
  // didn't have a chance alter it.
  if ($nids) {
    foreach ($nids as $nid => $created) {
      // Make sure the created value wasn't altered already.
      if (($group = group_get_group('node', $nid, TRUE)) && $group->created != $created) {
        $group->created = $created;
        group_save($group);

        // New group created, so add it to the total count.
        $context['count'] += 1;
      }
    }
  }

  return $found;
}

/**
 * Helper function; Upgrade "group content" nodes.
 */
function _group_upgrade_group_content(&$context) {
  $found = FALSE;

  // Operate on users in batches.
  $batch_size = 200;
  $query = db_select('node_revision', 'nr');
  $query->innerJoin('node', 'n', 'n.vid = nr.vid');
  $query->innerJoin('og_ancestry', 'oga', 'n.nid = oga.nid');
  $query
    ->fields('nr', array('nid', 'vid'))
    ->fields('n', array('type', 'created'))
    ->fields('oga', array('group_nid'))
    ->condition('nr.vid', $context['last'], '>')
    ->orderBy('nr.vid', 'ASC')
    ->range(0, $batch_size);
  $revisions = $query->execute();

  foreach ($revisions as $revision) {
    $group = group_get_group('node', $revision->group_nid);

    group_group($group->gid, 'node', $revision);

    $context['last'] = $account->nid;
    // User subscribed to group.
    $context['count'] += 1;
  }

  return $found;
}

/**
 * Helper function; Upgrade user subscription to groups.
 */
function _group_upgrade_user(&$context) {
  static $rid = 0;
  if (!$rid) {
    // Get the administrator role ID.
    $roles = array_flip(group_get_global_roles());
    $rid = $roles[GROUP_ADMINISTRATOR_ROLE];
  }

  $found = FALSE;

  // Operate on users in batches.
  $batch_size = 200;
  $query = db_select('og_uid', 'ogu');
  $query
    ->fields('ogu')
    ->condition('ogu.nid', $context['last'], '>')
    ->orderBy('ogu.nid', 'ASC')
    ->range(0, $batch_size);
  $accounts = $query->execute();

  foreach ($accounts as $account) {
    $group = group_get_group('node', $account->nid);
    $state = $account->is_active ? GROUP_STATE_ACTIVE : GROUP_STATE_PENDING;

    group_group($group->gid, 'user', $account, $state);

    if ($account->is_admin) {
      group_users_roles_grant($group->gid, $account->uid, $rid);
    }
    $context['last'] = $account->nid;
    // User subscribed to group.
    $context['count'] += 1;
  }

  return $found;
}