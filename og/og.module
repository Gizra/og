<?php
// $Id$

/**
 * @file
 * Enable users to create and manage groups with roles and permissions.
 */

// Load all Field module hooks for organic groups.
require(drupal_get_path('module', 'og') . '/og.field.inc');

// Dispositioning of content and memberships after deletion of a group node.
define('OG_DELETE_NOTHING', 0);
define('OG_DELETE_ORPHANS', 1);
define('OG_DELETE_MOVE_NODES', 2);
define('OG_DELETE_MOVE_NODES_MEMBERSHIPS', 3);

/**
 * Define active group content states.
 */
define('OG_STATE_ACTIVE', 'active');

/**
 * Define pending group content states. The user is subscribed to the group but
 * isn't an active member yet.
 */
define('OG_STATE_PENDING', 'pending');

/**
 * Define blocked group content states. The user is rejected from the group.
 */
define('OG_STATE_BLOCKED', 'blocked');


/**
 * Modules should return this value from hook_og_access() to allow access to a
 * group menu item.
 */
define('OG_ACCESS_ALLOW', 'allow');

/**
 * Modules should return this value from hook_og_access() to deny access to a
 * group menu item.
 */
define('OG_ACCESS_DENY', 'deny');

/**
 * Modules should return this value from hook_og_access() to not affect group
 * menu item access.
 */
define('OG_ACCESS_IGNORE', NULL);

/**
 * Group audience field.
 */
define('OG_AUDIENCE_FIELD', 'og_audience');

/**
 * The role name of group non-members.
 */
define('OG_ANONYMOUS_ROLE', 'anonymous member');

/**
 * The role name of group member.
 */
define('OG_AUTHENTICATED_ROLE', 'authenticated member');

/**
 * The role name of group administrator.
 */
define('OG_ADMINISTRATOR_ROLE', 'administrator');

/**
 * The role ID of the default group non-members.
 */
define('OG_ANONYMOUS_DEFAULT_RID', 1);

/**
 * The role ID of the default group member.
 */
define('OG_AUTHENTICATED_DEFAULT_RID', 2);

/**
 * The role ID of the default group administrator.
 */
define('OG_ADMINISTRATOR_DEFAULT_RID', 3);

/*******************************************************************************
 * Hook implementations
 ******************************************************************************/

/**
 * Implements hook_entity_info().
 */
function og_entity_info() {
  $return['og'] = array(
    'label' => t('Organic group'),
    'entity class' => 'EntityOg',
    'controller class' => 'OgController',
    'base table' => 'og_groups',
    'object keys' => array(
      'id' => 'gid',
    ),
  );
  return $return;
}

/**
 * Implements hook_entity_metadata_info().
 */
function og_entity_metadata_info() {
  $info = array();
  $properties = &$info['og']['properties'];

  $properties['gid'] = array(
    'label' => t("Group ID"),
    'type' => 'integer',
    'description' => t("The unique ID of the group."),
    'required' => TRUE,
  );

  $properties['oid'] = array(
    'label' => t("Object ID"),
    'type' => 'integer',
    'description' => t("The ID of the object."),
    'required' => TRUE,
  );

  $properties['obj_type'] = array(
    'label' => t("Object type"),
    'type' => 'text',
    'description' => t("The object type."),
    'required' => TRUE,
  );

  $properties['state'] = array(
    'label' => t("State"),
    'type' => 'text',
    'description' => t("The state of the group."),
    'setter callback' => 'entity_metadata_verbatim_set',
    'options list' => 'og_group_states',
  );

  return $info;
}

/**
 * Implements hook_entity_metadata_info_alter()
 */
function og_entity_metadata_info_alter(&$info) {
  $properties = &$info['user']['properties'];

  $properties['og-roles'] = array(
    'label' => t("Organic groups user roles"),
    'description' => t("The roles of the user in a group."),
    'type' => 'list<integer>',
    'getter callback' => 'og_user_get_properties',
    'setter callback' => 'og_user_set_properties',
    'options list' => 'og_user_roles',
  );
}


/**
 * Callback for getting user properties.
 *
 * @todo Get the group object.
 */
function og_user_get_properties($account, array $options, $name, $entity_type) {
  switch ($name) {
    case 'og-roles':
      return isset($account->roles) ? array_keys($account->roles) : array();
  }
}

/**
 * Callback for setting user properties.
 *
 * @todo Get the group object.
 */
function og_user_set_properties($account, $name, $value) {
  switch ($name) {
    case 'og-roles':
      $account->roles = array_intersect_key(user_roles(), array_flip($value));
      break;
  }
}



/**
 * Return the states a group can be in.
 */
function og_group_states() {
  return array(
    OG_STATE_ACTIVE => t('Active'),
    OG_STATE_PENDING => t('Pending'),
  );
}

/**
 * Return the states a group can be in.
 */
function og_group_content_states() {
  return array(
    OG_STATE_ACTIVE => t('Active'),
    OG_STATE_PENDING => t('Pending'),
    OG_STATE_BLOCKED => t('Blocked'),
  );
}

/*function test() {
  $group = og_load_multiple(array(52), array('obj_type' => 'node'));

  $post = node_load(51);
  $group[2]->set_association('node', $post);
}*/

/**
 * Controller class for organic groups.
 */
class OgController extends EntityAPIController {
	function load($ids = array(), $conditions = array()) {
		$gids = og_get_group_ids(!empty($conditions['obj_type']) ? $conditions['obj_type'] : 'gid', $ids);

		// Unset the object type condition.
		unset($conditions['obj_type']);
		return parent::load($gids, $conditions);
	}
}

/**
 * Main class for organic groups entities.
 */
class EntityOg extends EntityDB {

  public function __construct(array $values = array(), $entityType = NULL) {
    parent::__construct($values, 'og');
  }

  function load($ids = array(), $conditions = array()) {
    $gids = og_get_group_ids(!empty($conditions['obj_type']) ? $conditions['obj_type'] : 'gid', $ids);

    // Unset the object type condition.
    unset($conditions['obj_type']);
    return parent::load($gids, $conditions);
  }


	/**
	 * Set an association (e.g. subscribe) an object to a group.
	 *
	 * @param $obj_type
	 *   The object type (e.g. "node" or "user").
	 * @param $object
	 *   The object to set the association.
	 * @param $state
	 *   The state of the association. Can be OG_STATE_ACTIVE, OG_STATE_PENDING,
	 *   OG_STATE_BLOCKED.
	 */
	public function set_association($obj_type, $object, $state = OG_STATE_ACTIVE) {
	  // Re-load object to make sure we have the fields.
	  $object = og_load_object($obj_type, $object);

	  $wrapper = entity_metadata_wrapper($obj_type, $object);
    // Check if the object is already associated with the group.
    $existing_field = array();
    $property = str_replace('_', '-', OG_AUDIENCE_FIELD);

    if ($elements = $wrapper->{$property}->value()) {
    	foreach ($elements as $key => $value) {
    		if ($this->gid == $value) {
    			$existing_field = array(
    			  'key' => $key,
    			  'value' => $value,
    			);
    		}
    	}
    }

    if ($existing_field) {
      $values = array(
        'gid' => $this->gid,
        'state' => $state,
        'created' => $existing_field['created'],
        'changed' => time(),
      );
    	// Object already associated, check the state has changed.
    	$wrapper->{$property}[$existing_field['key']]->set($values);
    }
    else {
    	// Associate the object to the group.
    	$values = array(
    	  'gid' => $this->gid,
    	  'state' => $state,
    	  'created' => time(),
    	  'changed' => time(),
    	);
      $wrapper->{$property}->set($values);
    }
	}

	/**
	 * Delete an association (e.g. unsubscribe) an object to a group.
	 *
	 * @param $obj_type
	 *   The object type (e.g. "node" or "user").
	 * @param $object
	 *   The object to set the association.
	 */
	function og_delete_association($obj_type, $object, $gids = array()) {
	  // Load object to get the fields.
	  $object = og_load_object($obj_type, $object);

	  // Indicate if the object was changed, and needs to be saved.
	  $save = FALSE;

	  foreach ($object->og_audience[LANGUAGE_NONE] as $key => $group) {
	    if (in_array($group['gid'], $gids)) {
	      unset($object->og_audience[LANGUAGE_NONE][$key]);

	      og_invoke_event();
	      $save = TRUE;
	    }
	  }

	  if ($save) {
	    call_user_func('field_attach_update', $obj_type, $object);
	  }
	}

}


/**
 * Load multiple organic groups entities based on certain conditions.
 *
 * @param $gids
 *   An array of group entity IDs.
 * @param $conditions
 *   An array of conditions to match against the {entity} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 * @return
 *   An array of test entity objects, indexed by pid.
 */
function og_load_multiple($gids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('og', $gids, $conditions, $reset);
}

/**
 * Delete multiple organic groups entities.
 *
 * @param $gids
 *   An array of group entity IDs.
 */
function og_delete_multiple(array $gids) {
  entity_get_controller('og')->delete($gids);
}


/**
 * Get a group ID by the object type and object IDs.
 *
 * @param $oid
 *   The group content ID.
 * @param $obj_type
 *   The group object type. "node" is the default value. Pass "gid" if the the
 *   content ID is equal to the group unique ID.
 *
 * @return
 *   Array keyed with the object ID and the group ID as the value.
 */
function og_get_group_ids($obj_type, $oids = array()) {
	$gids = &drupal_static(__FUNCTION__, array());

	// If there are chached gids, temoprarly save them, so we don't re-query them
	// from the database.
	$cache_gids = array();

	if (!empty($gids[$obj_type])) {
		$oids = drupal_map_assoc($oids);
  	// Check we don't already have the group IDs.
  	foreach ($gids[$obj_type] as $oid => $gid) {
  		$cache_gids[$gid] = $gid;
  		unset($oids[$oid]);
  	}
	}

  if (!empty($oids)) {
	  if ($obj_type == 'gid') {
	  	$gids[$obj_type] = drupal_map_assoc($oids);
	  }
	  else {
		  $query = db_select('og_groups', 'og_groups');
		  $gids[$obj_type] = $query->fields('og_groups', array('oid', 'gid'))
		  ->condition('obj_type', $obj_type)
		  ->condition('oid', $oids, 'IN')
		  ->execute()->fetchAllKeyed();
	  }
  }

  // Add the cached group IDs.
  $gids[$obj_type] += $cache_gids;

  return $gids[$obj_type];
}

/**
 * Implements hook_permission().
 */
function og_permission() {
  return array(
    'administer organic groups' =>  array(
      'title' => t('Administer organic groups permissions'),
      'description' => t('Administer all groups and permissions.'),
    ),
  );
}

/**
 * Implement hook_init().
 */
function og_init() {
  og_context();
}

/**
* Implement hook_node_type_delete().
*/
function og_node_type_delete($info) {
  variable_del('og_group_type_' . $info->type);
  variable_del('og_group_content_type_' . $info->type);
}

/**
* Implement hook_node_type_insert().
*/
function og_node_type_insert($info) {
  og_node_type_save($info->type);
}

/**
* Implement hook_node_type_update().
*/
function og_node_type_update($info) {
  og_node_type_save($info->type);
}

/**
 * Add group and group content fields to new content types.
 *
 * @param $bundle_name
 *   The content type name.
 */
function og_node_type_save($bundle_name) {
  if (variable_get('og_group_type_' . $bundle_name, 'omitted') == 'group') {
    og_create_field('og_group','node', $bundle_name);
    // Delete the variable, as we will rely on the presence of th field.
    variable_del('og_group_type_' . $bundle_name);
  }
  if (variable_get('og_group_content_type_' . $bundle_name, 'omitted') == 'group_content') {
    og_create_field('og_audience','node', $bundle_name);
    // Delete the variable, as we will rely on the presence of th field.
    variable_del('og_group_content_type_' . $bundle_name);
  }
}

/**
 * Implement hook_og_permission().
 */
function og_og_permission() {
  return array(
    'update group' => array(
      'title' => t('Edit group'),
      'description' => t('Edit the group content.'),
    ),
    'update own group content' => array(
      'title' => t('Edit own group content'),
      'description' => t('Edit own group content that belong to the group.'),
    ),
    'update any group content' => array(
      'title' => t('Edit any group content'),
      'description' => t('Edit any group content that belong to the group.'),
    ),
    'delete own group content' => array(
      'title' => t('Delete own group content'),
      'description' => t('Delete own group content that belong to the group.'),
    ),
    'delete any group content' => array(
      'title' => t('Delete any group content'),
      'description' => t('Delete any of the group content that belong to the group.'),
    ),
    'administer group' => array(
      'title' => t('Administer group'),
      'description' => t('Manage or block users, and manage their role assignments in the group.'),
    ),
  );
}

/**
 * Implementation of hook_og_permission_default().
 */
function og_og_permission_default() {
  return array(
    OG_AUTHENTICATED_ROLE => array('update own group content', 'delete own group content'),
    OG_ADMINISTRATOR_ROLE => array('update group', 'update any group content', 'delete any group content', 'administer group'),
  );
}

/**
 * Implement hook_og_access().
 */
function og_og_access($op, $group, $account, $acting_user) {
  if ($group->obj_type == 'node' && og_user_access($group->oid, $op, $acting_user)) {
    return OG_ACCESS_ALLOW;
  }
  return OG_ACCESS_IGNORE;
}

/**
 * Implement hook_og_node_access()
 */
function og_og_node_access($node, $op, $account) {
  if (og_is_group_type('node', $node->type)) {
    $group = og_get_group('node', $node->nid);
    if (og_user_access($group->gid, $op . ' group', $account)) {
      return NODE_ACCESS_ALLOW;
    }
  }
  else {
    // We don't have a context, so we need to get all the permissions
    // of all the groups. We don't intersect with the user's group, as
    // groups might allow anonymous members access.
    $gids = array_keys(og_get_object_groups('node', $node));
    foreach ($gids as $gid) {
      if (og_user_access($gid, $op . ' group content', $account) || og_user_access($gid, $op . ' any group content', $account) || (og_user_access($gid, $op . ' own group content', $account) && $node->uid == $account->uid)) {
        return NODE_ACCESS_ALLOW;
      }
    }
  }
}

/**
 * Implement hook_node_access()
 */
function og_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);
  if ($op != 'create' && (og_is_group_type('node', $type) || og_is_group_content_type('node', $type))) {
    $access = module_invoke_all('og_node_access', $node, $op, $account);
    if (in_array(OG_ACCESS_DENY, $access, TRUE)) {
      return NODE_ACCESS_DENY;
    }
    elseif (in_array(OG_ACCESS_ALLOW, $access, TRUE)) {
      return NODE_ACCESS_ALLOW;
    }
  }
  // Not an organic group node type.
  return NODE_ACCESS_IGNORE;
}

/**
 * Implementation of hook_views_api().
 */
function og_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'og') . '/includes',
  );
}

/**
 * Get label information to fieldable entities.
 *
 * TODO: Implement hook_entity_info_alter().
 * TODO: see  http://drupal.org/node/629484 for discussion.
 *
 * @param $entity
 *   The entity name to populate with the label data.
 * @return
 *   The entity info merged with the label data.
 *
 */
function og_entity_label($entity) {
  $entity_info = entity_get_info($entity);

  $entity_labels = array(
    'comment' => 'subject',
    'node' => 'title',
    'file' => 'filename',
    'taxonomy_term' => 'name',
    'user' => 'name',
  );

  $entity_info['object keys']['label'] = $entity_labels[$entity];

  return $entity_info;
}

/**
 * Implement og_get_fields().
 */
function og_og_get_fields() {
  $items['og_group'] = array(
    'type' => array('group'),
    'description' => t('Determine if this should be a group.'),
    'field' => array(
      'field_name' => 'og_group',
      'type' => 'list_boolean',
      'cardinality' => 1,
      'settings' => array('allowed_values' => implode("\r\n", array('0|Not a group type', '1|Group type')), 'allowed_values_function' => ''),
    ),
    'instance' => array(
      'label' => t('Group type'),
      // FIXME: Widget type doesn't work
      'widget_type' => 'options_onoff',
      'display' => array(
        'full' => array(
          'label' => 'above',
          'type' => 'list_default',
        ),
        'teaser' => array(
          'label' => 'above',
          'type' => 'list_default',
        ),
      ),
    ),
  );


  $items['og_audience'] = array(
    'type' => array('group content'),
    'description' => t('Determine to which groups this group content is assigned to.'),
    'field' => array(
      'field_name' => 'og_audience',
      'type' => 'og',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
    ),
    'instance' => array(
      'label' => t('Groups audience'),
      'widget_type' => 'og_audience',
      'display' => array(
        'full' => array(
          'label' => 'above',
          'type' => 'og_list_default',
        ),
        'teaser' => array(
          'label' => 'above',
          'type' => 'og_list_default',
        ),
      ),
    ),
  );

  return $items;
}


/*******************************************************************************
 * API functions
 ******************************************************************************/

/**
 * Get a group object by the content ID.
 *
 * @param $oid
 *   The group content ID.
 * @param $obj_type
 *   The group object type. "node" is the default value. Pass "gid" if the the
 *   content ID is equal to the group unique ID.
 * @param $states
 *   Optional; Array with the states of the group (i.e. OG_STATE_ACTIVE or
 *   OG_STATE_PENDING).
 *
 * @return
 *   The group object if found, or an empty array.
 */
function og_get_group($obj_type, $oid, $states = array(OG_STATE_ACTIVE)) {
  $group = &drupal_static(__FUNCTION__, array());
  $result = array();

  if (empty($group[$obj_type][$oid])) {
    $query = db_select('og_groups', 'og_groups');
    $query->fields('og_groups');
    if ($obj_type != 'gid') {
      // The object type is not a real object - it's actually the group ID.
      $query->condition('oid', $oid)->condition('obj_type', $obj_type);
    }
    else {
      $query->condition('gid', $oid);
    }
    // Query for certain states if they are provided.
    if (!empty($states)) {
      $query->condition('state', $states, 'IN');
    }
    if ($result = $query->execute()->fetchObject()) {

      // Unserialize the data.
      $result->data = !empty($result->data) ? unserialize($result->data) : array();

      // Allow other modules to change the group object.
      drupal_alter('og_get_group', $result);
    }

    $group[$obj_type][$oid] = $result;
  }

  return $group[$obj_type][$oid];
}

/**
 * Get all groups IDs with a certain state.
 *
 * @param $obj_type
 *   The object type.
 * @param $oids
 *   Optional; Array with the object IDs to retreive, or empty to return all
 *   groups.
 * @param $states
 *   Optional; Array with the states of the group (i.e. OG_STATE_ACTIVE or
 *   OG_STATE_PENDING).
 *
 * @return
 *   Array with the object types as an array keyed by the group ID and the
 *   object ID as the value.
 */
function og_get_groups($obj_type = 'gid', $oids = array(), $states = array(OG_STATE_ACTIVE)) {
  $return = array();

  $query = db_select('og_groups', 'og_groups');
  $query->fields('og_groups');

  if ($obj_type != 'gid') {
    $query->condition('obj_type', $obj_type);
  }

  if (!empty($oids)) {
    if ($obj_type != 'gid') {
      $query->condition('oid', $oids, 'IN');
    }
    else {
      $query->condition('gid', $oids, 'IN');
    }
  }

  // Query for certain states if they are provided.
  if (!empty($states)) {
    $query->condition('state', $states, 'IN');
  }

  $result = $query->execute()->fetchAllAssoc('gid');

  foreach ($result as $row) {
    $return[$row->obj_type][$row->gid] = $row->oid;
  }
  return $return;
}

/**
 * Set a group object.
 *
 * @param $oid
 *   The group content ID.
 * @param $obj_type
 *   The group content ID. "node" is the default value.
 * @param $data
 *   Optional; An array with data related to the group.
 *
 * @return
 *   The group object populated with the group ID.
 */
function og_set_group($obj_type, $oid, $state = OG_STATE_ACTIVE, $data = array()) {
  $group = new stdClass();
  $group->obj_type = $obj_type;
  $group->oid = $oid;
  $group->state = $state;

  // Determine if object already exists and needs update.
  if ($existing_group = og_get_group($obj_type, $oid)) {
    $group->gid = $existing_group->gid;
    $existing_group->data = !empty($existing_group->data) ? unserialize($existing_group->data) : array();
    $group->data = array_merge($existing_group->data, $data);

    $update = array('gid');
  }
  else {
    $update = array();
    $group->data = $data;

  }

  // Allow other modules to change the group object.
  drupal_alter('og_set_group', $group);

  drupal_write_record('og_groups', $group, $update);

  return $group;
}


/**
 * Delete a group object by it's object type and ID.
 *
 * @param $obj_type
 *   The group object type ID or 'gid' to delete by group ID.
 * @param $oid
 *   Optional; The group ID. If empty all groups belonging to the object type
 *   will be deleted.
 */
function og_delete_groups($obj_type, $oids = array()) {
  $query = db_delete('og_groups');
  if ($obj_type != 'gid') {
    $query->condition('obj_type', $obj_type);
    if (!empty($oids)) {
      $query->condition('oid', $oids, 'IN');
    }
  }
  else {
    $query->condition('gid', $oids, 'IN');
  }

  $query->execute();
}

/**
 * Get all the users belonging to a group.
 *
 * @param $gid
 *   The group unique ID.
 * @param $count
 * @param $cursor
 *
 * @return
 *   Array keyed with the object IDs and the value as array with the field
 *   values.
 */
function og_get_group_users($gid, $states = array(OG_STATE_ACTIVE), $count = FIELD_QUERY_NO_LIMIT, &$cursor = 0) {
  $return = array();

  $field = field_info_field('og_audience');

  $conditions = array(
    array('gid', $gid),
    array('type', 'user'),
  );

  // Get the objects IDs.
  if ($result = field_attach_query($field['id'], $conditions, array('limit' => $count, 'cursor' => $cursor))) {
    $uids = array();
    foreach ($result['user'] as $key => $value) {
      $uids[$key] = $key;
    }

    // Load the users.
    $accounts = user_load_multiple($uids);

    // Prepare the return values.
    foreach ($accounts as $account) {
      $group = (object)og_get_group_from_object($gid, 'user', $account);

      // Check if the user's state is valid.
      if (!empty($states) && !in_array($group->state, $states)) {
        continue;
      }
      // OG audience may be multiple field, but the group can appear only once,
      // so we extract only the value with our requested group.
      $return[$account->uid] = $group;
      // Add back the user ID and user name.
      $return[$account->uid]->uid = $account->uid;
      $return[$account->uid]->name = $account->name;
    }
  }
  return $return;
}

/**
 * Extract a specific group from an object.
 *
 * @param $object
 *   The object.
 * @param $gid
 *   The group unqie ID.
 * @return
 *   Array with the field's value.
 */
function og_get_group_from_object($gid, $obj_type, $object, &$key = NULL) {
  $object = og_load_object($obj_type, $object);
  if (!empty($object->{OG_AUDIENCE_FIELD}[LANGUAGE_NONE])) {
    foreach ($object->{OG_AUDIENCE_FIELD}[LANGUAGE_NONE] as $key_index => $value) {
      if ($value['gid'] == $gid) {
        // Save the position of the value in the field.
        $key = $key_index;
        return $value;
      }
    }
  }
}

/**
 * Get the groups a content is associated with.
 *
 * @param $obj_type
 *   The object type (e.g. "node" or "user").
 * @param $object
 *   The object can be a user, node or any fieldable entity.
 * @param $states
 *   Optioanl; Array with the state to return. If empty all state will return.
 * @return
 *  An array with the group, or an empty array.
 */
function og_get_object_groups($obj_type, $object, $states = array(OG_STATE_ACTIVE)) {
  // Load object to get the fields.
  $object = og_load_object($obj_type, $object);

  $groups = array();
  if (!empty($object->{OG_AUDIENCE_FIELD}[LANGUAGE_NONE])) {
    foreach ($object->{OG_AUDIENCE_FIELD}[LANGUAGE_NONE] as $group) {
      if (!empty($states) && !in_array($group['state'], $states)) {
        // Don't register the group if it's state isn't the one we look for.
        continue;
      }
      $groups[$group['gid']] = $group['gid'];
    }
  }
  return $groups;
}

/**
 * Return the group type (i.e. "group" or "group_content") of an object.
 *
 * @param $bundle_name
 *   The bundle name to be checked.
 * @param $obj_type
 *   The object type.
 * @param $type
 *   The grou usage type. Must be "group" or "group content".
 *
 * @return
 *   The group type or an "omitted" if node type doesn't participate in
 *   organic groups.
 */
function og_get_group_type($obj_type, $bundle_name, $type = 'group') {
  if ($type == 'group') {
    return (bool)field_info_instance($obj_type, 'og_group', $bundle_name);
  }
  elseif ($type == 'group content') {
    return (bool)field_info_instance($obj_type, 'og_audience', $bundle_name);
  }
}

/**
 * Return TRUE if the object type is a "group" type.
 *
 * This is a wrapper function around og_get_group_type().
 *
 * @param $node_type
 *   The node type to be checked.
 */
function og_is_group_type($obj_type, $bundle_name) {
  return og_get_group_type($obj_type, $bundle_name);
}

/**
 * Return TRUE if the object type is a "group content" type.
 *
 * This is a wrapper function around og_get_group_type().
 *
 * @param $node_type
 *   The node type to be checked.
 */
function og_is_group_content_type($obj_type, $bundle_name) {
  return og_get_group_type($obj_type, $bundle_name, 'group content');
}

/**
 * Subscribe a user to groups.
 *
 * @param $groups
 *   Array of the groups to subscribe the user. The groups keys are:
 *   - gid: The group ID.
 *   - state: Optional; Defaults to OG_STATE_ACTIVE.
 *   - data: Optioanl; Defaults to an empty array().
 * @param $account
 *   Optional; A user object.
 * @param $replace
 *   Optioanl; True if the group lists should replace the existing subscrptions
 *   of the user.
 * @param $request
 *   Optioanl; A message created by the requesting user that should be sent to
 *   the group admins.
 */
function og_subscribe_user($groups = array(), $account = NULL, $replace = FALSE, $request = '') {
  if (empty($account)) {
    global $user;
    $account = $user;
  }
  og_set_association('user', $account, $groups, $replace, $request);
}

/**
 * Unsubscribe a user from groups.
 *
 * @param $gids
 *   Array of the groups to unsubscribe the user.
 * @param $account
 *   Optional; A user object.
 */
function og_unsubscribe_user($gids = array(), $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = $user;
  }

  og_delete_association('user', $account, $gids);

  // Delete any roles the user had.
  foreach ($gids as $gid) {
    foreach (og_get_user_roles($gid, $account->uid) as $rid) {
      og_users_roles_revoke($gid, $account->uid, $rid);
    }
  }
}

/**
 * Set an association (e.g. subscribe) an object to a group.
 *
 * @param $obj_type
 *   The object type (e.g. "node" or "user").
 * @param $object
 *   The object to set the association.
 * @param $groups
 *   Keyed array of the groups to subscribe the object. Keys are:
 *   "value" - The group ID.
 *   "state" - Optioanl; The state of the association.
 *   "data" - Optioanl; Array with data related to the association.
 * @param $replace
 *   Optioanl; True if the group lists should replace the existing subscrptions
 *   of the user.
 * @param $request
 *   Optioanl; A message created by the requesting user that should be sent to
 *   the group admins.
 */
function og_set_association($obj_type, $object, $groups = array(), $replace = FALSE, $request = '') {
  // Load object to get the fields.
  $object = og_load_object($obj_type, $object);

  $op = empty($object->og_audience) ? 'insert' : 'update';
  if ($replace) {
    unset($object->og_audience);
  }

  // Will be used later to keep only groups that are not yet associated with the
  // group.
  $existing_gids = og_get_object_groups($obj_type, $object, array());

  // Allow other modules to change the subscribed groups.
  drupal_alter('og_set_association', $groups, $obj_type, $object);

  // Indicate if the object was changed, and needs to be saved.
  $save = FALSE;

  foreach ($groups as $group) {
    $key = 0;
    if ($value = og_get_group_from_object($group['gid'], $obj_type, $object, $key)) {
      // Group already exists, so we will replace it. The key was returned from
      // og_get_group_from_object().
      // We preserve the data and state values, provided they aren't changed.
      $group = array_merge($value, $group);
      $object->og_audience[LANGUAGE_NONE][$key] = $group;
      $save = TRUE;
    }
    else {
      // Initialize values.
      $group += array('state' => OG_STATE_ACTIVE, 'data' => array());
      // Add a new record.
      $object->og_audience[LANGUAGE_NONE][] = $group;
      $save = TRUE;
    }
  }

  if ($save) {
    og_invoke_event();
    call_user_func('field_attach_' . $op, $obj_type, $object);
  }
}

/**
 * Set an association (e.g. subscribe) an object to a group.
 *
 * @param $obj_type
 *   The object type (e.g. "node" or "user").
 * @param $object
 *   The object to set the association.
 * @param $gids
 *   Array with the group IDs to delete.
 */
function og_delete_association($obj_type, $object, $gids = array()) {
  // Load object to get the fields.
  $object = og_load_object($obj_type, $object);

  // Indicate if the object was changed, and needs to be saved.
  $save = FALSE;

  foreach ($object->og_audience[LANGUAGE_NONE] as $key => $group) {
    if (in_array($group['gid'], $gids)) {
      unset($object->og_audience[LANGUAGE_NONE][$key]);

      og_invoke_event();
      $save = TRUE;
    }
  }

  if ($save) {
    call_user_func('field_attach_update', $obj_type, $object);
  }
}


/**
 * Menu callback; Central access point for all organic groups actions.
 *
 * Function is imittating hook_node_access().
 *
 * @param $op
 *   The operation name.
 * @param $node
 *   Optioanl; The node object.
 * @param $account
 *   Optioanl; The user related to the action. For example if the operation is
 *   "subscribe" then the account will be the subscribing user.
 * @param $acting_user
 *   Optioanl; The acting user. For example if the operation is
 *   "subscribe" then the acting user might be the admin who should approve
 *   or deny - according to this user access is decided.
 *   If this field is empty the current user is used.
 * @return
 *   TRUE if access is allowed, otherise FALSE.
 */
function og_access($op, $obj_type = NULL, $oid = NULL, $account = NULL, $acting_user = NULL) {
  if (empty($acting_user)) {
    global $user;
    $acting_user = $user;
  }
  if (user_access('administer organic groups', $acting_user)) {
    return TRUE;
  }

  if (!$group = og_get_group($obj_type, $oid)) {
    // Not a group.
    return FALSE;
  }

  // Get the group real object, so we can check the user ID of the object.
  $object = current(entity_load($obj_type, array($oid)));

  if (!empty($object->uid) && $object->uid == $acting_user->uid) {
    // Group manager.
    return TRUE;
  }

  $acting_user = og_load_object('user', $acting_user);
  if (!empty($account)) {
    $account = og_load_object('user', $account);
  }

  // Check if the user was blocked.
  if (($value = og_get_group_from_object($group->gid, 'user', $acting_user)) && $value['state'] == OG_STATE_BLOCKED) {
    return FALSE;
  }

  $access = module_invoke_all('og_access', $op, $group, $account, $acting_user);
  if (in_array(OG_ACCESS_DENY, $access, TRUE)) {
    return FALSE;
  }
  elseif (in_array(OG_ACCESS_ALLOW, $access, TRUE)) {
    return TRUE;
  }
  // No one allowed access, so assume access is denied.
  return FALSE;
}

/**
 * Get or set group context using the menu system.
 *
 * @param $account
 *   Optional; The user object to determine context form.
 * @param $group
 *   Optional; The group object to set as the context.
 * @return
 *   A group object, or FALSE if no context was found.
 */
function og_context($account = NULL, $group = NULL) {
  $context = &drupal_static(__FUNCTION__, FALSE);

  if (!empty($group)) {
    $context = $group;
  }

  if (empty($context)) {
    if (empty($account)) {
      global $user;
      $account = $user;
    }

    $item = menu_get_item();

    // Check the page arguments if one of them is an object, and check if it is
    // a group or group content, by looking for og_group or og_audience fields.
    if (!empty($item['page_arguments'])) {
      $obj_type = $item['map'][0];
      foreach ($item['page_arguments'] as $argument) {
        if (is_object($argument)) {
         // Check if it's a group.
          list($id) = entity_extract_ids($obj_type, $argument);
          if ($group = og_get_group($obj_type, $id)) {
            $groups = array($group->gid => $group->gid);
          }
          else {
            $groups = og_get_object_groups($obj_type, $argument);
          }
          // TODO: Add context based on ?gid_gids[] in URL.
          if (!empty($groups)) {
            // Get the user's group and try to intersect.
            $user_groups = og_get_object_groups('user', $account);
            if ($intersect_gids = array_intersect($groups, $user_groups)) {
              $gid = reset($intersect_gids);
            }
            else {
              // The user is not a member of any of the groups. Let's check
              // if it's a node, as node access might be FALSE.
              $groups = og_get_groups('gid', $groups);
              // For performance reasons we prefer not to use node_access()
              // so we first check if the group content is associated with
              // non-node groups.
              if (!empty($groups['node'])) {
                $node_gids = $groups['node'];
                unset($groups['node']);
                if (!empty($groups)) {
                  $gids = reset($groups);
                  $gid = reset($gid);
                }
                else {
                  // We have only nodes as groups, so check access to them.
                  // TODO: have og_get_group_mulitple().
                  foreach ($node_gids as $node_gid) {
                    $group = og_get_group('gid', $node_get);
                    $nid = $group->oid;
                    $node = node_load($nid);
                    if (node_access('view', $node, $account)) {
                      $gid = $group->gid;
                      break;
                    }
                  }
                }
              }
            }

            if (!empty($gid)) {
              $group = og_get_group('gid', $gid);
            }
          }
        }
      }

      if (!empty($group)) {
        $context = $group;
      }
    }
  }

  return $context;
}

/**
 * Add the group object of the context to the Drupal javascript object.
 *
 * @param $group
 *   A group object.
 */
function og_context_js($group) {
  // Static variable to indicate if group was already added to javacript.
  $js = &drupal_static(__FUNCTION__, FALSE);
  if (empty($js)) {
    drupal_add_js(array('og' => array('og_context' => $group)), 'setting');
    $js = TRUE;
  }
}

/**
 * Add context related templates and CSS.
 */
function og_preprocess_page(&$vars) {
  if ($group = og_context()) {
    // Add template suggestions.
    $vars['theme_hook_suggestions'][] = 'page__og_context';
    $vars['theme_hook_suggestions'][] = 'page__og_context_' . $group->gid;
    $vars['theme_hook_suggestions'][] = 'page__og_context_' . $group->obj_type;
    $vars['theme_hook_suggestions'][] = 'page__og_context_' . $group->obj_type . '_' . $group->oid;

    // Add CSS.
    $vars['classes_array'][] = 'og-context';
    $vars['classes_array'][] = 'og-context-' . $group->gid;
    $vars['classes_array'][] = 'og-context-' . $group->obj_type;
    $vars['classes_array'][] = 'og-context-' . $group->obj_type . '-' . $group->oid;

    // Add context to JS.
    og_context_js($group);
  }
}


/*******************************************************************************
 * Function callbacks
 ******************************************************************************/

/**
 * Create an array of allowed values for OG audience field.
 *
 * @return
 *   Array keyed by "content groups" and "other groups".
 */
function og_allowed_values($field, $account = NULL) {
  $allowed_values = &drupal_static(__FUNCTION__, array());

  if (isset($allowed_values[$field['field_name']])) {
    return $allowed_values[$field['field_name']];
  }

  if (empty($account)) {
    global $user;

    $account = $user;
  }
  $allowed_values[$field['field_name']] = og_get_groups_for_form('user', $account);
  return $allowed_values[$field['field_name']];
}

/**
 * Get the groups a content belongs to - ready to be used in a form element.
 *
 * @param $obj_type
 *   The object type (e.g. "node" or "user").
 * @param $object
 *   The object can be a user, node or any fieldable entity.
 * @return
 *   An array keyed by "content groups" and "other groups". Inside them there are
 *   the group's node ID and the sanitized group's name.
 *
 * @see og_get_groups_of_content().
 */
function og_get_groups_for_form($obj_type, $object) {
  $return = array('content groups' => array(), 'other groups' => array());
  // Get all the existing groups.

  // Get the groups belonging to the content.
  if ($all_groups = og_get_all_groups_for_form()) {
    $content_groups = og_get_object_groups($obj_type, $object);

    // TODO: Is it faster to use array_diff & array_intersect?
    foreach ($all_groups as $nid => $name) {
      if (in_array($nid, $content_groups)) {
        $return['content groups'][$nid] = $name;
      }
      else {
        $return['other groups'][$nid] = $name;
      }
    }
  }

  return $return;
}

/**
 * Get all groups keyed by group ID and the title ready to be used on forms.
 */
function og_get_all_groups_for_form($gids = array()) {
  $return = array();

  foreach (og_get_groups('gid', $gids) as $obj_type => $values) {
    $return = $return + og_entity_get_label_multiple($obj_type, $values);
  }

  // Sanitize the result.
  array_walk($return, 'check_plain');
  return $return;

}

/**
 * Get the label (e.g. node title) of different entities.
 *
 * @param $obj_type
 *   The object type.
 * @param $oids
 *   The object IDs.
 * @return
 *   Array keyed with the group unqiue ID and the object label as the value.
 */
function og_entity_get_label_multiple($obj_type, $oids = array()) {
  $return = array();

  // Get the group IDs.
  $gids = og_get_groups($obj_type, $oids);
  $gids = !empty($gids[$obj_type]) ? array_keys($gids[$obj_type]) : array();

  $entity = og_entity_label($obj_type);

  // Get the table, ID and label of the object type.
  if (!empty($entity['object keys']['label'])) {

    $table = $entity['base table'];
    $id = $entity['object keys']['id'];
    $label = $entity['object keys']['label'];

    // Get the group ID along with the object label.
    $query = db_select('og_groups', 'og')->fields('og', array('gid'));
    $query->condition('gid', $gids, 'IN');

    $query->join($table, $table, "og.oid =  $table.$id");

    $return = $query->fields($table, array($label))
      ->condition($id, $oids, 'IN')
      ->execute()
      ->fetchAllKeyed();
  }
  else {
    // We got an object type that we don't know how to get the label, so we'll
    // return the group ID as the laebl, prefixed with the object type.
    foreach ($oids as $oid) {
      $return[$oid] = t('@obj_type ID  @value', array('@obj_type' => $obj_type, '@value' => $oid));
    }
  }

  return $return;
}

/**
 * Wrapper function to get the label of a single entity.
 *
 * @param $obj_type
 *   The object type.
 * @param $oid
 *   The object ID.
 * @return unknown_type
 */
function og_entity_get_label($obj_type, $oid) {
  return current(og_entity_get_label_multiple($obj_type, array($oid)));

}

/**
 * Wrapper function to invoke an event.
 */
function og_invoke_event() {
  if (module_exists('rules')) {
    // Invoke a Rules event.
  }
}

/**
 * Return a re-loaded object with its fields.
 *
 * This is needed only if a user account is passed, as global $user is only a
 * partial user object.
 *
 * @param $obj_type
 *   The object type.
 * @param $object
 *   The object.
 */
function og_load_object($obj_type, $object) {
  if ($obj_type == 'user') {
    $object = user_load($object->uid);
  }
  return $object;
}

/**
 * Determine the permissions for one or more roles.
 *
 * @param $roles
 *   An array whose keys are the role IDs of interest, such as $user->roles.
 *
 * @return
 *   An array indexed by role ID. Each value is an array whose keys are the
 *   permission strings for the given role ID.
 */
function og_user_role_permissions($roles = array()) {
  $cache = &drupal_static(__FUNCTION__, array());

  $role_permissions = $fetch = array();

  if ($roles) {
    foreach ($roles as $rid => $name) {
      if (isset($cache[$rid])) {
        $role_permissions[$rid] = $cache[$rid];
      }
      else {
        // Add this rid to the list of those needing to be fetched.
        $fetch[] = $rid;
        // Prepare in case no permissions are returned.
        $cache[$rid] = array();
      }
    }

    if ($fetch) {
      // Get from the database permissions that were not in the static variable.
      // Only role IDs with at least one permission assigned will return rows.
      $result = db_query("SELECT rid, permission FROM {og_role_permission} WHERE rid IN (:fetch)", array(':fetch' => $fetch));

      foreach ($result as $row) {
        $cache[$row->rid][$row->permission] = TRUE;
      }
      foreach ($fetch as $rid) {
        // For every rid, we know we at least assigned an empty array.
        $role_permissions[$rid] = $cache[$rid];
      }
    }
  }

  return $role_permissions;
}

/**
 * Determine whether the user has a given privilege.
 *
 * @param $gid
 *   The group ID.
 * @param $string
 *   The permission, such as "administer nodes", being checked for.
 * @param $account
 *   (optional) The account to check, if not given use currently logged in user.
 *
 * @return
 *   Boolean TRUE if the current user has the requested permission.
 *
 * All permission checks in OG should go through this function. This
 * way, we guarantee consistent behavior, and ensure that the superuser
 * can perform all actions.
 */
function og_user_access($gid, $string, $account = NULL) {
  global $user;
  $perm = &drupal_static(__FUNCTION__, array());

  if (empty($account)) {
    $account = $user;
  }

  // User #1 has all privileges.
  if ($account->uid == 1) {
    return TRUE;
  }

  // Administer organic groups permission.
  if (user_access('administer organic groups', $account)) {
    return TRUE;
  }

  if (!$group = og_get_group('gid', $gid)) {
    // Not a group.
    return FALSE;
  }

  // Group manager has all privileges.
  $object= current(entity_load($group->obj_type, array($group->oid)));
  if (!empty($object->uid) && $object->uid == $account->uid) {
    return TRUE;
  }

  // To reduce the number of SQL queries, we cache the user's permissions
  // in a static variable, if the user is authenticated.
  if (!isset($perm[$gid][$account->uid])) {
    $user_groups = og_get_object_groups('user', $account);

    // Get default roles.
    $default_roles = og_get_group_default_roles($gid);
    if (!in_array($gid, $user_groups)) {
      // Keep only the anonymous role.
      $roles = drupal_map_assoc(array($default_roles[OG_ANONYMOUS_ROLE]));
    }
    else {
      // Add the authenticated role.
      $roles = drupal_map_assoc(array($default_roles[OG_AUTHENTICATED_ROLE]));
      // Get otehr roles assigned to the user in the group.
      $roles += og_get_user_roles($gid, $account->uid);
    }

    $role_permissions = og_user_role_permissions($roles);

    $perms = array();
    foreach ($role_permissions as $one_role) {
      $perms += $one_role;

      $perm[$gid][$account->uid] = $perms;
    }

  }
  return isset($perm[$gid][$account->uid][$string]);
}


/**
 * Retrieve an array of roles matching specified conditions.
 * @param $gid
 *   The group node ID.
 * @param $roles
 * @param $permission
 *   Optioanl; A string containing a permission. If set, only roles containing that
 *   permission are returned.
 *
 * @return
 *   An associative array with the role id as the key and the role name as
 *   value. The anonymous and authenticated deault roles are on the top of the
 *   array.
 */
function og_user_roles($gid, $roles = array(), $permission = NULL) {
  if (!empty($permission)) {
    $roles = db_query("SELECT r.rid, r.name FROM {og_role} r INNER JOIN {og_role_permission} p ON r.rid = p.rid WHERE p.permission = :permission AND r.gid = :gid ORDER BY r.name", array(':permission' => $permission, ':gid' => $gid))->fetchAllKeyed();
  }
  else {
    $roles = db_query("SELECT rid, name FROM {og_role} WHERE gid = :gid ORDER BY name = :anon AND name = :auth AND name", array(':gid' => $gid, ':anon' => OG_ANONYMOUS_ROLE, ':auth' => OG_AUTHENTICATED_ROLE))->fetchAllKeyed();
  }

  // Filter to remove unmatched system roles.
  return  array_filter($roles);
}

/**
 * Get the anonymous and authenticated user roles ID of a group.
 *
 * @param $gid
 *   The group ID.
 * @return
 *   A keyed array with "anonymous" and "authenticaed".
 */
function og_get_group_default_roles($gid) {
  return db_query("SELECT name, rid FROM {og_role} WHERE gid = :gid AND (name = :anon OR name = :auth OR name = :admin)", array(':gid' => $gid, ':anon' => OG_ANONYMOUS_ROLE, ':auth' => OG_AUTHENTICATED_ROLE, ':admin' => OG_ADMINISTRATOR_ROLE))->fetchAllKeyed();
}

/**
 * Get all roles ID of a group.
 *
 * @param $gid
 *   The group ID.
 * @return
 *   An array keyed with the role name and the role ID as the value.
 */
function og_get_group_roles($gid) {
  return db_query("SELECT name, rid FROM {og_role} WHERE gid = :gid", array(':gid' => $gid))->fetchAllKeyed();
}

/**
 * Get all roles ID of a user in a certain group.
 *
 * @param $gid
 *   The group ID.
 * @param $uid
 *   The user ID.
 * @return
 *   Array with the role IDs of the user.
 */
function og_get_user_roles($gid, $uid) {
  //TODO: How to get keyed by rid, wihout this hack?
  return db_query("SELECT rid, rid FROM {og_users_roles} WHERE uid = :uid AND gid = :gid", array(':uid' => $uid, ':gid' => $gid))->fetchAllKeyed();
}

/**
 * Get all the users with certain roles in a group.
 *
 * @param $gid
 *   The group unique ID.
 * @param $roles
 *   Array with the roles to query.
 */
function og_get_users_by_roles($gid, $roles = array()) {
  $query = db_select('og_users_roles', 'og_users_roles');
  return $query->fields('og_users_roles', array('uid'))
    ->condition('gid', $gid)
    ->condition('role', $roles, 'IN')
    ->execute()
    ->fetchAll();
}


/**
 * Fetch a user role from database.
 *
 * @param $rid
 *   An integer with the role ID.
 * @return
 *   A fully-loaded role object if a role with the given name or ID
 *   exists, FALSE otherwise.
 */
function og_user_role_load($rid) {
  $result = db_query("SELECT * FROM {og_role} WHERE rid = :rid", array(':rid' => $rid));
  return $result->fetchObject();
}
/**
 * Save a user role to the database.
 *
 * @param $role
 *   A role object to modify or add. If $role->rid is not specified, a new
 *   role will be created.
 * @return
 *   Status constant indicating if role was created or updated.
 *   Failure to write the user role record will return FALSE. Otherwise.
 *   SAVED_NEW or SAVED_UPDATED is returned depending on the operation
 *   performed.
 */
function og_user_role_save($role) {
  if ($role->name) {
    // Prevent leading and trailing spaces in role names.
    $role->name = trim($role->name);
  }
  if (!empty($role->rid) && $role->name) {
    $status = drupal_write_record('og_role', $role, 'rid');
    module_invoke_all('og_user_role_update', $role);
  }
  else {
    $status = drupal_write_record('og_role', $role);
    module_invoke_all('og_user_role_insert', $role);
  }

  // Clear the user access cache.
  drupal_static_reset('og_user_access');
  drupal_static_reset('og_user_role_permissions');

  return $status;
}

/**
 * Delete a user role from database.
 *
 * @param $role
 *   A string with the role name, or an integer with the role ID.
 */
function og_user_role_delete($rid) {
  $role = og_user_role_load($rid);

  db_delete('og_role')
    ->condition('rid', $rid)
    ->execute();
  db_delete('og_role_permission')
    ->condition('rid', $rid)
    ->execute();
  // Update the users who have this role set.
  db_delete('og_users_roles')
    ->condition('rid', $rid)
    ->execute();

  module_invoke_all('og_user_role_delete', $role);

  // Clear the user access cache.
  drupal_static_reset('og_user_access');
  drupal_static_reset('og_user_role_permissions');
}

/**
 * Grant a group role to a user.
 *
 * @param $uid
 *   The user ID.
 * @param $rid
 *   The role ID.
 */
function og_users_roles_grant($gid, $uid, $rid) {
  // Get the existiong user roles.
  $user_roles = og_get_user_roles($gid, $uid);
  if (!in_array($rid, $user_roles)) {
    $role = new stdClass();
    $role->uid = $uid;
    $role->rid = $rid;
    $role->gid = $gid;

    drupal_write_record('og_users_roles', $role);
    og_invoke_event();
    module_invoke_all('og_users_roles_grant', $gid, $uid, $rid);
  }
}

/**
 * Revoke a group role from a user.
 *
 * @param $uid
 *   The user ID.
 * @param $rid
 *   The role ID.
 */
function og_users_roles_revoke($gid, $uid, $rid) {
  // Get the existiong user roles.
  $user_roles = og_get_user_roles($gid, $uid);
  if (in_array($rid, $user_roles)) {

    db_delete('og_users_roles')
      ->condition('uid', $uid)
      ->condition('rid', $rid)
      ->execute();
    module_invoke_all('og_users_roles_revoke', $gid, $uid, $rid);
  }

}

/**
 * Change permissions for a user role.
 *
 * This function may be used to grant and revoke multiple permissions at once.
 * For example, when a form exposes checkboxes to configure permissions for a
 * role, the submitted values may be directly passed on in a form submit
 * handler.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   An array of permissions, where the key holds the permission name and the
 *   value is an integer or boolean that determines whether to grant or revoke
 *   the permission:
 *   @code
 *     array(
 *       'administer nodes' => 0,
 *       'access user profiles' => 1,
 *     )
 *   @endcode
 *   Existing permissions are not changed, unless specified in $permissions.
 *
 * @see og_user_role_grant_permissions()
 * @see og_user_role_revoke_permissions()
 */
function og_user_role_change_permissions($rid, array $permissions = array()) {
  // Grant new permissions for the role.
  $grant = array_filter($permissions);
  if (!empty($grant)) {
    og_user_role_grant_permissions($rid, array_keys($grant));
  }
  // Revoke permissions for the role.
  $revoke = array_diff_assoc($permissions, $grant);
  if (!empty($revoke)) {
    og_user_role_revoke_permissions($rid, array_keys($revoke));
  }
}

/**
 * Grant permissions to a user role.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   A list of permission names to grant.
 *
 * @see user_role_change_permissions()
 * @see user_role_revoke_permissions()
 */
function og_user_role_grant_permissions($rid, array $permissions = array()) {
  // Grant new permissions for the role.
  foreach ($permissions as $name) {
    db_merge('og_role_permission')
      ->key(array(
        'rid' => $rid,
        'permission' => $name,
      ))
      ->execute();
  }

  // Clear the user access cache.
  drupal_static_reset('og_user_access');
  drupal_static_reset('og_user_role_permissions');
}

/**
 * Revoke permissions from a user role.
 *
 * @param $rid
 *   The ID of a user role to alter.
 * @param $permissions
 *   A list of permission names to revoke.
 *
 * @see user_role_change_permissions()
 * @see user_role_grant_permissions()
 */
function og_user_role_revoke_permissions($rid, array $permissions = array()) {
  // Revoke permissions for the role.
  db_delete('og_role_permission')
    ->condition('rid', $rid)
    ->condition('permission', $permissions, 'IN')
    ->execute();

  // Clear the user access cache.
  drupal_static_reset('og_user_access');
  drupal_static_reset('og_user_role_permissions');
}


/**
 * Get all permissions defined for organic groups.
 */
function og_permissions_get() {
  $perms = &drupal_static(__FUNCTION__, array());
  if (!empty($perms)) {
    return $perms;
  }

  foreach (module_implements('og_permission') as $module) {
    if ($permissions = module_invoke($module, 'og_permission')) {
      foreach ($permissions as $key => $perm) {
        // Initialize the roles key, if other modules haven't set it explicetly.
        // This means the permissions can apply to anonymous and authenticaed
        // members as-well.
        $permissions[$key] += array('roles' => array(OG_ANONYMOUS_ROLE, OG_AUTHENTICATED_ROLE));
      }
      $perms[$module] = $permissions;
    }
  }

  if (user_access('administer organic groups')) {
    $return = array();
    // Allow user to define which administration permissions a group admin can
    // set.
    foreach ($perms as $module => $permissions) {
      foreach ($permissions as $key => $perm) {
        $return['administer']['show ' . $key] = array(
          'title' => t('Show %perm', array('%perm' => strtolower($perm['title']))),
          'description' => t("Allow setting the %perm permission in the group permissions page.", array('%perm' => strtolower($perm['title']))),
          // Add all roles, as this option allows setting which permisisons
          // a role has access to.
          'roles' => array(OG_ANONYMOUS_ROLE, OG_AUTHENTICATED_ROLE, OG_ADMINISTRATOR_ROLE),
        );
      }
    }
    $perms = $perms + $return;
  }
  return $perms;
}

/**
 * Get default permissions as set by implementing modules.
 *
 * @return
 *   Array keyed with the anonymous, authenticated and administror and the
 *   permissions that should be enabled by default.
 */
function og_permissions_default_get() {
   $perms = module_invoke_all('og_permission_default');
   $perms += array(OG_ANONYMOUS_ROLE => array(), OG_AUTHENTICATED_ROLE => array(), OG_ADMINISTRATOR_ROLE => array());
   return $perms;
}

/**
 * Get all the modules fields that can be assigned to fieldable enteties.
 */
function og_get_fields() {
  $return = &drupal_static(__FUNCTION__, array());

  if (!empty($return)) {
    return $return;
  }

  foreach (module_implements('og_get_fields') as $module) {
    if ($fields = module_invoke($module, 'og_get_fields')) {
      foreach ($fields as $key => $field) {
        // Add the module information.
        $return[$key] = array_merge($field, array('module' => $module));
      }
    }
  }
  return $return;
}

/**
 * Update the permissions of all existing groups.
 *
 * @param $permissions
 *   The name of the permissions that need to be updated. Other permissions will
 *   not be affected by this operation.
 *
 * @return
 *   The number of groups that were updated.
 *
 */
function og_permissions_bulk_update($roles, $permissions) {
  // Handle only the permissions that were set to be bulk updated.
  $permissions = array_filter($permissions);

  // An array with the permissions that need to be set, keyed by the role name.
  $permissions_to_change = array();
  // Filter out only the needed permissions from the roles.
  foreach ($roles as $rid => $perms) {
    foreach ($perms as $perm => $value) {
      if (in_array($perm, $permissions)) {
        switch ($rid) {
          case 1:
            $role_name = OG_ANONYMOUS_ROLE;
            break;

          case 2:
            $role_name = OG_AUTHENTICATED_ROLE;
            break;

          case 3:
            $role_name = OG_ADMINISTRATOR_ROLE;
            break;
        }

        $permissions_to_change[$role_name][$perm] = $value;
      }
    }
  }

  // The number of groups that are bulk updated.
  $updated_groups = 0;

  if (!empty($permissions_to_change)) {
    // Get all existing group node IDs.
    foreach (og_get_groups() as $obj_type => $values) {
      foreach ($values as $gid) {
        ++$updated_groups;
        $rids = og_get_group_default_roles($gid);
        foreach ($rids as $name => $rid) {
          og_user_role_change_permissions($rid, $permissions_to_change[$name]);
        }
      }
    }
  }
  return $updated_groups;
}

/**
 * Add default roles and permissions to a new group.
 *
 * @param $gid
 *   The node ID of the group or 0 for default permissions.
 */
function og_set_new_group_roles($gid = 0) {
  // Create default roles.
  $role = new stdClass;
  $role->name = OG_ANONYMOUS_ROLE;
  $role->gid = $gid;
  og_user_role_save($role);
  $anon_rid = $role->rid;

  unset($role->rid);
  $role->name = OG_AUTHENTICATED_ROLE;
  og_user_role_save($role);
  $auth_rid = $role->rid;

  unset($role->rid);
  $role->name = OG_ADMINISTRATOR_ROLE;
  og_user_role_save($role);
  $admin_rid = $role->rid;

  // Create default permissions for roles.
  $perms = og_permissions_default_get();

  og_user_role_grant_permissions($anon_rid, $perms[OG_ANONYMOUS_ROLE]);
  og_user_role_grant_permissions($auth_rid, $perms[OG_AUTHENTICATED_ROLE]);
  og_user_role_grant_permissions($admin_rid, $perms[OG_ADMINISTRATOR_ROLE]);
}

/**
 * Get a private token used to protect links from spoofing - CSRF.
 */
function og_get_token($gid) {
  return drupal_get_token($gid);
}

/**
 * Check to see if a token value matches the specified node.
 */
function og_check_token($token, $seed) {
  return drupal_get_token($seed) == $token;
}

function og_set_breadcrumb($obj_type, $oid, $path = array()) {
  if ($label = og_entity_get_label($obj_type, $oid)) {
    drupal_set_breadcrumb(array_merge(array(l(t('Home'), '<front>')), array(l($label, "$obj_type/$oid")), $path)) ;
  }
}

/**
 * Create a field in a bundle.
 *
 * @param $field_name
 *   The field name
 * @param $obj_type
 *   The object type
 * @param $bundle
 *   The bundle name.
 */
function og_create_field($field_name, $obj_type, $bundle) {
  $og_field = og_get_fields($field_name);

  if (!empty($og_field['callback'])) {
    // Field has own implementation for creating the fields.
    call_user_func($og_field['callback'], $field_name, $obj_type, $bundle);
  }
  else {
    $field = field_info_field($field_name);
    if (empty($field)) {
      $field = field_create_field($og_field[$field_name]['field']);
    }

    $instance = field_info_instance($obj_type, $field_name, $bundle);
    if (empty($instance)) {

      $instance = array(
        'field_name' => $field_name,
        'bundle' => $bundle,
        'object_type' => $obj_type,
      ) + $og_field[$field_name]['instance'];

      field_create_instance($instance);
    }
  }
}
